from _typeshed import Incomplete
from langchain_core.runnables import Runnable
from langchain_core.runnables.config import RunnableConfig as RunnableConfig
from langchain_core.runnables.graph import Graph as DrawableGraph
from langgraph.constants import Send
from langgraph.pregel import Pregel
from langgraph.pregel.write import ChannelWrite
from langgraph.types import All as All, Checkpointer as Checkpointer
from langgraph.utils.runnable import RunnableCallable, RunnableLike as RunnableLike
from typing import Any, Awaitable, Callable, Hashable, NamedTuple, Sequence, overload
from typing_extensions import Self

logger: Incomplete

class NodeSpec(NamedTuple):
    runnable: Runnable
    metadata: dict[str, Any] | None = ...
    ends: tuple[str, ...] | dict[str, str] | None = ...

class Branch(NamedTuple):
    path: Runnable[Any, Hashable | list[Hashable]]
    ends: dict[Hashable, str] | None
    then: str | None = ...
    def run(self, writer: Callable[[Sequence[str | Send], RunnableConfig], ChannelWrite | None], reader: Callable[[RunnableConfig], Any] | None = None) -> RunnableCallable: ...

class Graph:
    nodes: Incomplete
    edges: Incomplete
    branches: Incomplete
    support_multiple_edges: bool
    compiled: bool
    def __init__(self) -> None: ...
    @overload
    def add_node(self, node: RunnableLike, *, metadata: dict[str, Any] | None = None) -> Self: ...
    @overload
    def add_node(self, node: str, action: RunnableLike, *, metadata: dict[str, Any] | None = None) -> Self: ...
    def add_edge(self, start_key: str, end_key: str) -> Self: ...
    def add_conditional_edges(self, source: str, path: Callable[..., Hashable | list[Hashable]] | Callable[..., Awaitable[Hashable | list[Hashable]]] | Runnable[Any, Hashable | list[Hashable]], path_map: dict[Hashable, str] | list[str] | None = None, then: str | None = None) -> Self: ...
    def set_entry_point(self, key: str) -> Self: ...
    def set_conditional_entry_point(self, path: Callable[..., Hashable | list[Hashable]] | Callable[..., Awaitable[Hashable | list[Hashable]]] | Runnable[Any, Hashable | list[Hashable]], path_map: dict[Hashable, str] | list[str] | None = None, then: str | None = None) -> Self: ...
    def set_finish_point(self, key: str) -> Self: ...
    def validate(self, interrupt: Sequence[str] | None = None) -> Self: ...
    def compile(self, checkpointer: Checkpointer = None, interrupt_before: All | list[str] | None = None, interrupt_after: All | list[str] | None = None, debug: bool = False, name: str | None = None) -> CompiledGraph: ...

class CompiledGraph(Pregel):
    builder: Graph
    def __init__(self, *, builder: Graph, **kwargs: Any) -> None: ...
    def attach_node(self, key: str, node: NodeSpec) -> None: ...
    def attach_edge(self, start: str, end: str) -> None: ...
    def attach_branch(self, start: str, name: str, branch: Branch) -> None: ...
    async def aget_graph(self, config: RunnableConfig | None = None, *, xray: int | bool = False) -> DrawableGraph: ...
    def get_graph(self, config: RunnableConfig | None = None, *, xray: int | bool = False) -> DrawableGraph: ...
