from langchain_core.runnables.base import Input, Output
from langchain_core.runnables.config import RunnableConfig
from langchain_core.runnables.graph import Graph as Graph
from langchain_core.runnables.utils import ConfigurableFieldSpec
from langgraph.channels.base import BaseChannel
from langgraph.checkpoint.base import BaseCheckpointSaver, CheckpointTuple as CheckpointTuple
from langgraph.managed.base import ManagedValueSpec as ManagedValueSpec
from langgraph.pregel.protocol import PregelProtocol
from langgraph.pregel.read import PregelNode
from langgraph.pregel.retry import RetryPolicy as RetryPolicy
from langgraph.pregel.write import ChannelWrite
from langgraph.store.base import BaseStore as BaseStore
from langgraph.types import All as All, Checkpointer as Checkpointer, StateSnapshot, StreamMode as StreamMode
from pydantic import BaseModel as BaseModel
from typing import Any, AsyncIterator, Callable, Iterator, Sequence, overload
from typing_extensions import Self

WriteValue = Callable[[Input], Output] | Any

class Channel:
    @overload
    @classmethod
    def subscribe_to(cls, channels: str, *, key: str | None = None, tags: list[str] | None = None) -> PregelNode: ...
    @overload
    @classmethod
    def subscribe_to(cls, channels: Sequence[str], *, key: None = None, tags: list[str] | None = None) -> PregelNode: ...
    @classmethod
    def write_to(cls, *channels: str, **kwargs: WriteValue) -> ChannelWrite: ...

class Pregel(PregelProtocol):
    nodes: dict[str, PregelNode]
    channels: dict[str, BaseChannel | ManagedValueSpec]
    stream_mode: StreamMode
    stream_eager: bool
    output_channels: str | Sequence[str]
    stream_channels: str | Sequence[str] | None
    interrupt_after_nodes: All | Sequence[str]
    interrupt_before_nodes: All | Sequence[str]
    input_channels: str | Sequence[str]
    step_timeout: float | None
    debug: bool
    checkpointer: Checkpointer
    store: BaseStore | None
    retry_policy: RetryPolicy | None
    config_type: type[Any] | None
    config: RunnableConfig | None
    name: str
    def __init__(self, *, nodes: dict[str, PregelNode], channels: dict[str, BaseChannel | ManagedValueSpec] | None, auto_validate: bool = True, stream_mode: StreamMode = 'values', stream_eager: bool = False, output_channels: str | Sequence[str], stream_channels: str | Sequence[str] | None = None, interrupt_after_nodes: All | Sequence[str] = (), interrupt_before_nodes: All | Sequence[str] = (), input_channels: str | Sequence[str], step_timeout: float | None = None, debug: bool | None = None, checkpointer: BaseCheckpointSaver | None = None, store: BaseStore | None = None, retry_policy: RetryPolicy | None = None, config_type: type[Any] | None = None, config: RunnableConfig | None = None, name: str = 'LangGraph') -> None: ...
    def get_graph(self, config: RunnableConfig | None = None, *, xray: int | bool = False) -> Graph: ...
    async def aget_graph(self, config: RunnableConfig | None = None, *, xray: int | bool = False) -> Graph: ...
    def copy(self, update: dict[str, Any] | None = None) -> Self: ...
    def with_config(self, config: RunnableConfig | None = None, **kwargs: Any) -> Self: ...
    def validate(self) -> Self: ...
    @property
    def config_specs(self) -> list[ConfigurableFieldSpec]: ...
    @property
    def InputType(self) -> Any: ...
    def get_input_schema(self, config: RunnableConfig | None = None) -> type[BaseModel]: ...
    def get_input_jsonschema(self, config: RunnableConfig | None = None) -> dict[All, Any]: ...
    @property
    def OutputType(self) -> Any: ...
    def get_output_schema(self, config: RunnableConfig | None = None) -> type[BaseModel]: ...
    def get_output_jsonschema(self, config: RunnableConfig | None = None) -> dict[All, Any]: ...
    @property
    def stream_channels_list(self) -> Sequence[str]: ...
    @property
    def stream_channels_asis(self) -> str | Sequence[str]: ...
    def get_subgraphs(self, *, namespace: str | None = None, recurse: bool = False) -> Iterator[tuple[str, PregelProtocol]]: ...
    async def aget_subgraphs(self, *, namespace: str | None = None, recurse: bool = False) -> AsyncIterator[tuple[str, PregelProtocol]]: ...
    def get_state(self, config: RunnableConfig, *, subgraphs: bool = False) -> StateSnapshot: ...
    async def aget_state(self, config: RunnableConfig, *, subgraphs: bool = False) -> StateSnapshot: ...
    def get_state_history(self, config: RunnableConfig, *, filter: dict[str, Any] | None = None, before: RunnableConfig | None = None, limit: int | None = None) -> Iterator[StateSnapshot]: ...
    async def aget_state_history(self, config: RunnableConfig, *, filter: dict[str, Any] | None = None, before: RunnableConfig | None = None, limit: int | None = None) -> AsyncIterator[StateSnapshot]: ...
    def update_state(self, config: RunnableConfig, values: dict[str, Any] | Any | None, as_node: str | None = None) -> RunnableConfig: ...
    async def aupdate_state(self, config: RunnableConfig, values: dict[str, Any] | Any, as_node: str | None = None) -> RunnableConfig: ...
    def stream(self, input: dict[str, Any] | Any, config: RunnableConfig | None = None, *, stream_mode: StreamMode | list[StreamMode] | None = None, output_keys: str | Sequence[str] | None = None, interrupt_before: All | Sequence[str] | None = None, interrupt_after: All | Sequence[str] | None = None, debug: bool | None = None, subgraphs: bool = False) -> Iterator[dict[str, Any] | Any]: ...
    async def astream(self, input: dict[str, Any] | Any, config: RunnableConfig | None = None, *, stream_mode: StreamMode | list[StreamMode] | None = None, output_keys: str | Sequence[str] | None = None, interrupt_before: All | Sequence[str] | None = None, interrupt_after: All | Sequence[str] | None = None, debug: bool | None = None, subgraphs: bool = False) -> AsyncIterator[dict[str, Any] | Any]: ...
    def invoke(self, input: dict[str, Any] | Any, config: RunnableConfig | None = None, *, stream_mode: StreamMode = 'values', output_keys: str | Sequence[str] | None = None, interrupt_before: All | Sequence[str] | None = None, interrupt_after: All | Sequence[str] | None = None, debug: bool | None = None, **kwargs: Any) -> dict[str, Any] | Any: ...
    async def ainvoke(self, input: dict[str, Any] | Any, config: RunnableConfig | None = None, *, stream_mode: StreamMode = 'values', output_keys: str | Sequence[str] | None = None, interrupt_before: All | Sequence[str] | None = None, interrupt_after: All | Sequence[str] | None = None, debug: bool | None = None, **kwargs: Any) -> dict[str, Any] | Any: ...
