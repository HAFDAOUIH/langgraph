import asyncio
import concurrent.futures
from _typeshed import Incomplete
from langchain_core.runnables import RunnableConfig as RunnableConfig
from types import TracebackType as TracebackType
from typing import AsyncContextManager, Awaitable, Callable, ContextManager, Coroutine, Protocol, TypeVar
from typing_extensions import ParamSpec

P = ParamSpec('P')
T = TypeVar('T')

class Submit(Protocol[P, T]):
    def __call__(self, fn: Callable[P, T], *args: P.args, __name__: str | None = None, __cancel_on_exit__: bool = False, __reraise_on_exit__: bool = True, __next_tick__: bool = False, **kwargs: P.kwargs) -> concurrent.futures.Future[T]: ...

class BackgroundExecutor(ContextManager):
    stack: Incomplete
    executor: Incomplete
    tasks: Incomplete
    def __init__(self, config: RunnableConfig) -> None: ...
    def submit(self, fn: Callable[P, T], *args: P.args, __name__: str | None = None, __cancel_on_exit__: bool = False, __reraise_on_exit__: bool = True, __next_tick__: bool = False, **kwargs: P.kwargs) -> concurrent.futures.Future[T]: ...
    def done(self, task: concurrent.futures.Future) -> None: ...
    def __enter__(self) -> Submit: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> bool | None: ...

class AsyncBackgroundExecutor(AsyncContextManager):
    tasks: Incomplete
    sentinel: Incomplete
    loop: Incomplete
    semaphore: Incomplete
    def __init__(self, config: RunnableConfig) -> None: ...
    def submit(self, fn: Callable[P, Awaitable[T]], *args: P.args, __name__: str | None = None, __cancel_on_exit__: bool = False, __reraise_on_exit__: bool = True, __next_tick__: bool = False, **kwargs: P.kwargs) -> asyncio.Future[T]: ...
    def done(self, task: asyncio.Future) -> None: ...
    async def __aenter__(self) -> Submit: ...
    async def __aexit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> None: ...

async def gated(semaphore: asyncio.Semaphore, coro: Coroutine[None, None, T]) -> T: ...
def next_tick(fn: Callable[P, T], *args: P.args, **kwargs: P.kwargs) -> T: ...
